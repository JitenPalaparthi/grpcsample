// Package handlers contains all http restful handlers
// Author : readyGo "JitenP@Outlook.Com"
// This code is generated by readyGo. You are free to make amendments as and where required
package handlers

import (
	"context"
	"grpcsample/interfaces"
	"grpcsample/models"
	pb "grpcsample/protos"
	"flag"
	"github.com/golang/glog"
	"github.com/fatih/structs"
	"github.com/mitchellh/mapstructure"
)

// Product type used as a container for db interface and receiver for handler functions
type Product struct {
	IProduct interfaces.ProductInterface
	pb.UnimplementedProductServer
}

func init() {
	flag.Parse()
	flag.Lookup("logtostderr").Value.Set("true")
}

// CreateProduct is to create object
func (p *Product) CreateProduct(ctx context.Context, in *pb.ProductType) (*pb.ProductResponse, error) {
	product := &models.Product{}
	
	sm := structs.Map(in)
	err:=mapstructure.Decode(sm, product)
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	/*
	product.Name=in.Name
	product.Description=in.Description
	product.RefNo=in.RefNo
	product.HasStock=in.HasStock
	product.Status=in.Status
	product.LastModified=in.LastModified
	product.Address=in.Address
	product.ID=in.ID*/
	out := &pb.ProductResponse{}
	if err := models.ValidateProduct(product); err != nil {
		glog.Error(err)
		return nil, err
	}
	result,err:=p.IProduct.CreateProduct(product);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Code = 201
	out.Message = result
	return out, nil
}
// UpdateProductByID is to update object in database
func (p *Product) UpdateProductByID(ctx context.Context, in *pb.ProductUpdateRequest) (*pb.ProductResponse, error) {
	out := &pb.ProductResponse{}
	result,err:=p.IProduct.UpdateProductByID(in.ID,in.Data.AsMap());
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Code = 200
	out.Message = result
	return out, nil
}

// DeleteProductByID is to delete object from database
func (p *Product) DeleteProductByID(ctx context.Context, in *pb.ProductIDRequest) (*pb.ProductResponse, error) {
	out := &pb.ProductResponse{}
	result,err:=p.IProduct.DeleteProductByID(in.ID);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Code = 200
	out.Message = result
	return out, nil
}

// GetProductByID is to fetch object based on ID
func (p *Product) GetProductByID(ctx context.Context, in *pb.ProductIDRequest) (*pb.ProductType, error) {
	product := &models.Product{}

	product ,err:=p.IProduct.GetProductByID(in.ID);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out := &pb.ProductType{}
	sm := structs.Map(product)
	err=mapstructure.Decode(sm, out)
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	/*
	out.Name=product.Name
	out.Description=product.Description
	out.RefNo=product.RefNo
	out.HasStock=product.HasStock
	out.Status=product.Status
	out.LastModified=product.LastModified
	out.Address=product.Address
	out.ID=product.ID*/
	return out, nil
}


// GetAllProductsBy is to fetch all objects based on provided parameters
func (p *Product) GetAllProductsBy(ctx context.Context, in *pb.ProductGetAllByRequest) (*pb.ProductsResponse, error) {
	products := make([]models.Product,0)
	products ,err:=p.IProduct.GetAllProductsBy(in.Key,in.Value,in.Skip,in.Limit);
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out := &pb.ProductsResponse{}
	for _,product:=range products{
	single := &pb.ProductType{}
	
	/*
	single.Name=product.Name
	single.Description=product.Description
	single.RefNo=product.RefNo
	single.HasStock=product.HasStock
	single.Status=product.Status
	single.LastModified=product.LastModified
	single.Address=product.Address
	single.ID=product.ID*/
	sm := structs.Map(product)
	err = mapstructure.Decode(sm, single)
	if err!=nil{
		glog.Info(err)
		return nil, err
	}
	out.Products = append(out.Products,single)
	}
	return out, nil
}